---
title: "Using STvEA to analyze CODEX data"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(STvEA)
```

## Read in CODEX data
Dataframe converted from FCS files at http://welikesharingdata.blob.core.windows.net/forshare/index.html
```{r}
data("codex_balbc1")
```

### Take corner section of CODEX data
The clustering and Adjacency Score functions are fairly slow on large numbers of cells.
```{r}
codex_subset <- codex_spatial$x < 3000 & codex_spatial$y < 3000
codex_protein <- codex_protein[codex_subset,]
codex_blanks <- codex_blanks[codex_subset,]
codex_size <- codex_size[codex_subset]
codex_spatial <- codex_spatial[codex_subset,]
```

## Create object to hold data
The STvEA.data class conveniently handles the required data frames and matrices between function calls.
```{r}
stvea_object <- SetDataCODEX(codex_protein = codex_protein,
                             codex_blanks = codex_blanks,
                             codex_size = codex_size,
                             codex_spatial = codex_spatial)
```

## Filter and clean protein expression
Remove cells that are too small or large, or have too low or too high expression in the blank channels.
If lower and upper limits aren't specified, the 0.002 and 0.95 quantiles are taken as the limits for blank expression, and the 0.022 and 0.99 quantiles are taken as the limits for size.
Then normalize data by the total counts per cell
```{r}
stvea_object <- FilterCODEX(stvea_object, size_lim = c(1000,25000),
                            blank_lower = c(-1200, -1200, -1200, -1200),
                            blank_upper = c(6000,2500,5000,2500))
```

Fit a Gaussian mixture model to the expression levels of each protein.
New data will be the cumulative probability according to the Gaussian with the higher mean
```{r}
stvea_object <- CleanCODEX(stvea_object)
```

## Cluster CODEX cells based on protein expression
Compute the 2 dimensional UMAP embedding of the cleaned CODEX protein expression for later visualization. 
UMAP also returns the KNN indices with k = n_neighbors.
```{r}
# This will take around 5 minutes for ~10000 cells
stvea_object <- GetUmapCODEX(stvea_object, metric = 'pearson', n_neighbors=30,
                             min_dist=0.1, negative_sample_rate = 50)
```

Use the KNN indices from UMAP to perform Louvain clustering
```{r}
stvea_object <- ClusterCODEX(stvea_object, k=30)
```

## Visualize clustering and protein expression 
Color each cell in the CODEX UMAP embedding with its cluster assignment.
Cells in gray were not assigned to any cluster.
```{r}
PlotClusterCODEXemb(stvea_object)
```

Color each cell in the CODEX UMAP embedding with its expression level of proteins.
One or two protein names can be input. If two protein names are provided,
color will be interpolated between red and green color values.
```{r}
PlotExprCODEXemb(stvea_object, c("CD4","B220"))
```

Color the CODEX spatial slide with the expression level of proteins.
One or two protein names can be input. If two protein names are provided,
color will be interpolated between red and green color values.
```{r}
PlotExprCODEXspatial(stvea_object, c("CD4","B220"))
```

## Assess colocalization of clusters
Run the Adjacency Score (https://github.com/CamaraLab/AdjacencyScore) to evaluate how often
two features take high values in adjacent nodes in a KNN graph of the CODEX spatial dimensions.

Assess which pairs of clusters often appear in adjacent cells
```{r}
cluster_adj <- AdjScoreClustersCODEX(stvea_object, k=3)
AdjScoreHeatmap(cluster_adj)
```

Assess which pairs of proteins are often highly expressed in adjacent cells
```{r}
protein_adj <- AdjScoreProteins(stvea_object, k=3, num_cores=8)
AdjScoreHeatmap(protein_adj)
```
