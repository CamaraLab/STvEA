---
title: "Using STvEA to map CODEX and CITE-seq data"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(STvEA)
```

## Read in CODEX data
Dataframe converted from FCS files at http://welikesharingdata.blob.core.windows.net/forshare/index.html
```{r}
data("codex_balbc1")
```

### Take corner section of CODEX data
The clustering and Adjacency Score functions are fairly slow on large numbers of cells.
```{r}
codex_subset <- codex_spatial$x < 3000 & codex_spatial$y < 3000
codex_protein <- codex_protein[codex_subset,]
codex_blanks <- codex_blanks[codex_subset,]
codex_size <- codex_size[codex_subset]
codex_spatial <- codex_spatial[codex_subset,]
```

## Read in CITE-seq data
```{r}
# link to CITE-seq data on Dropbox
```

## Create object to hold data
The STvEA.data class conveniently handles the required data frames and matrices between function calls.
```{r}
stvea_object <- SetDataCODEX(codex_protein = codex_protein,
                             codex_blanks = codex_blanks,
                             codex_size = codex_size,
                             codex_spatial = codex_spatial)
stvea_object <- SetDataCITE(cite_mRNA = cite_mRNA,
                            cite_protein = cite_protein,
                            cite_latent = cite_latent,
                            stvea_object = stvea_object)
```

## Filter and clean CODEX protein expression
Remove cells that are too small or large, or have too low or too high expression in the blank channels.
If lower and upper limits aren't specified, quantiles are taken as the limits.
Then normalize data by the total counts per cell
```{r}
stvea_object <- FilterCODEX(stvea_object, size_lim = c(1000, 25000),
                            blank_lower = c(-1200, -1200, -1200, -1200),
                            blank_upper = c(6000, 2500, 5000, 2500))
```

Fit a Gaussian mixture model to the expression levels of each protein.
New data will be the cumulative probability according to the Gaussian with the higher mean
```{r}
stvea_object <- CleanCODEX(stvea_object)
```

## Clean and normalize CITE-seq protein expression
```{r}
stvea_object <- CleanCITE(stvea_object, num_cores=8)
```

## Cluster CITE-seq cells based on mRNA expression
```{r}
stvea_object <- GetUmapCITE(stvea_object, n_neighbors = 50, min_dist=0.1, negative_sample_rate=50)
```

```{r}
stvea_object <- ParameterScan(stvea_object, seq(5,20,4), seq(10,40,3), n_neighbors=50, min_dist=0.1, negative_sample_rate=50)
```

```{r}
stvea_object <- ConsensusCluster(stvea_object, 0.1, 0.3, 10)
```

## Cluster CODEX cells based on protein expression
Compute the 2 dimensional UMAP embedding of the cleaned CODEX protein expression for later visualization. 
UMAP also returns the KNN indices with k = n_neighbors.
```{r}
# This will take around 5 minutes for ~10000 cells
stvea_object <- GetUmapCODEX(stvea_object, metric = 'pearson', n_neighbors=30,
                             min_dist=0.1, negative_sample_rate = 50)
```

Use the KNN indices from UMAP to perform Louvain clustering
```{r}
stvea_object <- ClusterCODEX(stvea_object, k=30)
```

## Map CITE-seq and CODEX protein
```{r}
stvea_object <- CorrectChunksCODEX(stvea_object, num_chunks=8, seed=30, num_cores=4)
```

## Create neighbor matrices
```{r}
stvea_object <- GetTransferMatrix(stvea_object)
```

## Visualize clustering, mRNA, and protein expression 
Color each cell in the CITE-seq UMAP embedding with its cluster assignment.
Cells in gray were not assigned to any cluster.
```{r}
PlotClusterCITE(stvea_object)
```

Color each cell in the CITE-seq UMAP embedding with its expression level of one of two genes. If two gene names are provided, color will be interpolated between red and green color values.
```{r}
PlotExprCITE(stvea_object, c("Cd4", "Ighd"), type="RNA")
```

Color each cell in the CITE-seq UMAP embedding with its expression level of one of two proteins.
```{r}
PlotExprCITE(stvea_object, c("CD4","IgD"), type="protein")
```

Color each cell in the CODEX UMAP embedding with its cluster assignment.
Cells in gray were not assigned to any cluster.
```{r}
PlotClusterCODEXemb(stvea_object)
```

Color each cell in the CODEX UMAP embedding with its expression level of one or two proteins.
```{r}
PlotExprCODEXemb(stvea_object, c("CD4","IgD"))
```

Color the CODEX spatial slide with the expression level of one or two proteins.
```{r}
PlotExprCODEXspatial(stvea_object, c("CD4","IgD"))
```

Color the CODEX spatial slide with the expression level of one or two genes that were mapped from the CITE-seq expression levels. 
```{r}
PlotExprCODEXspatial(stvea_object, c("Cd4", "IgD"), type="RNA")
```

## Assess colocalization of clusters
Run the Adjacency Score (https://github.com/CamaraLab/AdjacencyScore) to evaluate how often
two features take high values in adjacent nodes in a KNN graph of the CODEX spatial dimensions.

Assess which pairs of clusters often appear in adjacent cells
```{r}
cluster_adj <- AdjScoreClustersCODEX(stvea_object, k=3)
AdjScoreHeatmap(cluster_adj)
```

Assess which pairs of proteins are often highly expressed in adjacent cells
```{r}
protein_adj <- AdjScoreProteins(stvea_object, k=3, num_cores=8)
AdjScoreHeatmap(protein_adj)
```

Assess which pairs of genes from the given list are often highly expressed in adjacency cells. There are too many genes to compute the Adjacency Score for all combinations
```{r}
gene_adj <- AdjScoreGenes(stvea_object, k=3, num_cores=8)
```


